from openmm.app import PDBFile
from scipy.optimize import minimize
import numpy as np
import openmm.unit as uu

class BFGS2(object):
    def __init__(self, context, out_pdb=None, topology=None):
        #raise NotImplementedError("Still working on BFGS Minimizer")
        self._out_file = None
        self._topology = topology
        self._step_num = 0
        self._context = context
        if out_pdb is not None and topology is not None:
            self._out_file = open(out_pdb, 'w')

        #   only use atoms that are not lone pairs (element == None) or have non-zero mass
        self._force_index_list = []
        for atom in topology.atoms():
            if atom.element is None: continue
            mass = atom.element.mass
            mass = mass/mass.unit
            if mass == 0: continue
            self._force_index_list.append(atom.index)

        self._current_all_pos = np.empty(len(self._force_index_list))

    def _callback(self, pos):
        
        if self._out_file is not None:
            PDBFile.writeModel(self._topology, self._current_all_pos.reshape(-1,3)*uu.nanometer, file=self._out_file, modelIndex=self._step_num)
        self._step_num += 1


    def minimize(self, tolerance=10*uu.kilojoules_per_mole/uu.nanometer, maxIterations=500):
        init_state = self._context.getState(getForces=True, getEnergy=True, getPositions=True)
        self._current_all_pos = init_state.getPositions(True).value_in_unit(uu.nanometer)
        init_pos = self._current_all_pos[self._force_index_list].flatten()
        init_energy, init_forces = self._target_func(init_pos, self._context)
        force_norms = [np.linalg.norm(f) for f in init_forces]
        print(" Initial max. force: {:15.3f} kJ/mol".format(np.max(force_norms)))
        print(" Initial energy:     {:15.3f} kJ/mol/nm".format(init_energy))
        dim = len(init_pos)

        

        self._step_num = 0
        args = (self._context, True)
        self._callback(init_pos)
        res = minimize(self._target_func, init_pos, 
            args=args, 
            method='l-bfgs-b', 
            jac=True, 
            callback=self._callback,
            options={'maxiter': maxIterations, 'disp': True, 'gtol': 10, 'maxfun': maxIterations*3*dim})
        final_pos = res.x.reshape(-1,3)

        final_energy, final_forces = self._target_func(final_pos, self._context)
        force_norms = [np.linalg.norm(f) for f in final_forces]
        print(" Final max. force:   {:15.3f} kJ/mol".format(np.max(force_norms)))
        print(" Final energy:       {:15.3f} kJ/mol/nm".format(final_energy))
        if self._out_file is not None:
            self._out_file.close()


    def _target_func(self, pos, context, return_deriv=True):

        pos_to_set = np.copy(self._current_all_pos).reshape(-1, 3)
        pos = np.reshape(pos, (-1, 3))
        for idx, new_pos in zip(self._force_index_list, pos):
            pos_to_set[idx] = new_pos
        context.setPositions(pos_to_set)
        context.applyConstraints(0.0001)

        state = context.getState(getEnergy=True, getForces=True, getPositions=True)
        forces_all = state.getForces(asNumpy=True).value_in_unit(uu.kilojoule_per_mole/uu.nanometer)
        forces = np.array([forces_all[idx] for idx in self._force_index_list])
        energy = state.getPotentialEnergy().value_in_unit(uu.kilojoule_per_mole)
        self._current_all_pos = state.getPositions(True).value_in_unit(uu.nanometer).flatten()

        atoms = list(self._topology.atoms())
        force_norms = np.linalg.norm(forces, axis=1)
        for n, idx in enumerate(self._force_index_list):
            print(idx, atoms[idx], force_norms[n])
        print(np.argmax(force_norms), np.max(force_norms), len(forces))
        exit()

        #print(len(forces), len(forces_all), forces)

        if return_deriv:
            return energy, -forces.flatten()
        else:
            return energy